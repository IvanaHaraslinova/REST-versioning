\chapter{Versioning access}
\label{chap:versionaccess}

/TODO


\section{Version identifiers}
Version is typicaly identified by decimal number. The number is composed from a minor and a major number. Their incerase can be based on the amount of work which have been done between two releases of versions or the compatibility regarding the two versions. This approaches can be combined.

\section{Accsess approaches}
Deployment of the versions can be performed different ways. There are two main approaches:
\begin{enumerate}
  \item Version parameter
  \item Multiple endpoint addresses
\end{enumerate}

\subsection{Version parameter}
Every consumer of the services uses the same endpoint address to access the services. Single service has the same address for any of its implementations. Then then the object of versioning is the implementation. Behind one service which is accessed by one URI there are possibly more implementatios.
To access a requested version of the implementation it's used version parameter. It is present in request message sent by consumer. Thanks to the parameter the request is routed to appropriate implementation version.

This approach is advantage for consumers, release of new version has minimal impact on them. But on the other side it requires a special attention on version strategy, it can lead to collision of names, database names, ect.

\subsection{Multiple endpoint addresses}
In this approach each service version is deployed independently and has its own endpoint address. This time consumer is obliged to know which service and implementation versions wants to access. When a customer wants to pass to newer version he needs to make changes in request addresses. The advantage of the approach is that the names collisaions are eliminated by indipendent deployment of service versions. But the routing is more complex and requres addressing registry for resolving the addresses.

/TODO zdroj Vesioning in SOA, obrazky

There are a lots of different teories and opinions about the right approach to implementation of the versioning. The most discussed are the URI versioning and versioning using the headers. Uri versioning represents a multiple endpoint addresses approach described above and vesion in headers represents the version parameter approach.

\section{Versioning using URI}
Version in URI is broadly used solution how to version. The version is displayed in the URI address:

\texttt{http:/api.com/v1/accounts/123}

This approach is easy to understand. The URI change when a new verion is released so that it routes to the right version. But this appriach brings a lot of disadvatages. There are more option how to handle with consumers - let the consumer change the URI everytime the version changes, or a consumer obtains fixed URI or the consumer can change its implementation from scratch, which does not involve many work, but it is unaccetable regarding a user.
Everyone form this option is constraining the flexibility.
The version should not influence the consumer usability of the system and has to have minimal possible impact on it. If the consumer should change the routing everytime he switch to the new version it is not good and there are possibilities how to access the version better.

Moreover having a look at the REST constraints, as they are described by Fitztadidaa, this approach violates the HATEOS principle. 
/TODO finish section 

The URI containing version can be used for internal purposes, when the code is debugged and tested, but in the production should not be present.

\section{Versioning based on headers}
\subsection{Link header}
The link header can be used to define version of the service which should be used. When the request is sent the consumer obtain a response which is enriched by the link. When consumer uses the old verion of the service he just ignores the link. The user of the new service can follow the added link and reach the newest version of the response.

\texttt{http://example.com/v2/rels/v2-equivalent}

\texttt{GET /accounts/123 HTTP/1.1}

\texttt{HTTP/1.1 200 OK}
\texttt{link: <http://example.com/v2/orders/super-widget>; rel="alternate http://example.com/v2/rels/v2-equivalent"}

%\subsection{Location}

\subsection{MIME Types}

\texttt{GET /accounts/123 HTTP/1.1}

\texttt{Accept: application/vnd.v2+json}
