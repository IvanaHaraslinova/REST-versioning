\chapter{Representative State Transfer (REST)}
\label{chap:rest}

%% (sekce \ref{subsec:features}) 

\section{REST architecture}
\label{sec:rest-architecture}

The REST is an architectural style. "a set of constraints on the overall arichitectural approach"(agile argitecture). The goal of REST is to create a distributed hypermedia application It is resource-based, which means that it handles with resources instead of making actions, resources are named by nouns, and the actions are provided by HTTP requests. Rest architecture is client-server.
RESTful web services have their best practices and constraints. There are 6 constraints characterizing the REST. 

REST architecture has its elements, which do not define the technologies of implementation but are abstraction of the components behaviour. Components have its roles, the way of interaction among them and interpretation.

REST arcitecture is a composition of elements, connectors and components.

The data elements are:

\begin{description}
  \item [resource] 
  Resource is an abstraction of information in REST, where any information which can be named can be a resource. A resource is a conceptual mapping to a set of entities, or values \cite{fielding}. The values can be a resource identifier and a representation.
  \item [resource identifier] 
  It serves to identify resources which interact with componets. The resource identifier is assigned the name thanks to which it is possible to reference the recource.
  \item [representation] 
  Rapresentation is used by REST components to perform changes of the resource. The format of representations data is called media type and have influence on the performance or the hypermedia system  
  \item [representation metadata] 
  This metadata describes the data of which the represenation consists of.
   \item [resource metadata] 
  Resource metadata stores an information about the resource that is not specific to the supplied representation.
  \item [control data]
  Control data decribes the purpose of a message between components
  %% R http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
\end{description}

The connectors provides the access point for the values of the resource. In connectors belong client, server, cache, resolver, tunnel 

REST components are an abstraction of application unit. The components are origin server, gateway, proxy, user agent.


\section{REST rapresentation}
Every resource has its representation, it describes how resources get manipulated in RESTful  API architecture. The representation represents part of (or less commonly the whole) resource state, it is transferred between the client and server and has generally the JSON or XML format, but could be in many more other formats as well. The representation is composed from resource and attached files which provide enough information for the client to be able to modify the resource on the server.

\section{REST constraints}

Six constraints that are applied to the architecture to create RESTful services. Respecting this rules leads to desiderable properties of the system, such as performance, scalability, simplicity, modifiability, visibility, portability and reliability. 
%%(citacia http://www.restapitutorial.com/lessons/whatisrest.html#)
\begin{description}
  \item The six constraints are:

\begin{enumerate}
  \item Uniform Interface
  
Define interface between client and server. It separates client and server allowing them to develop each part independently. The interface is uniform, so that is
easier to understand for both, the server and the client.
Interface is resource-based - requests in \emph {URI} (Uniform Resource Idetifier) contain the resource identifiers which identifies the concrete resource. To the client is then sent the representation which is conceptually separated from the resource. The representation is commonly in HTML, XML or JSON format and represents appropriate database record.
Resources are manipulated exclusively throught the rapresentations. The representation with any metadata attached, keeps enough information for the client and allow him to modify the resource on the server.
The sentmessage which represents the request sent by client or the response form the server is self-decriptive. That means there is enough information to know hov to process the message and the response explicitely defines the cashability.
The representation is sent using \emph{HTTP specification}, client call the resource using HTTP verbs (GET, POST, PUT, DELETE,..) and the URI, server sends to the client the HTTP response.


  \item Stateless

The messages in REST architecture are stateless, the state can be stored via \emph {HATEOAS} (Hypermedia as the Engine ot Application State). From client side, the state can be delivered through body content of the message (request), query parematers in the URI, headers in request. From server side the state can be delivered via body content of the message (response), response code and respone header. 
The necessary state is contained within the request, there are more options how to store it, whether it can be a part od the URI, query-string paremeter, header or body.The Uri identifies the concrete resource and the body includes the state. Then after process the message the state is send back to the client via headers, status and response body.
The statelessness allows greater scalability, because server doesn't have to cammunicate with the session, which creatiaon is necessary to carry the state using some other design of services.


Each message is self-descriptive, has enough context to be processable by the server. Messages has no state. If the state is needed, the representation is what is holding it.?????

(Session state is therefore kept entirely on the client.

Visibility is improved because a monitoring system does not have to look beyond a single request datum in order to determine the full nature of the request. Reliability is improved because it eases the task of recovering from partial failures [133]. Scalability is improved because not having to store state between requests allows the server component to quickly free resources, and further simplifies implementation because the server doesn't have to manage resource usage across requests.

The disadvantage is that it may decrease network performance by increasing the repetitive data. The data cannot be left on the server in a shared context. Placing the application state on the client-side reduces the server's control over consistent application behavior, application is dependent on the clients implementation) %http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

\item Client-server

RESTful architecture is client-server architecture. There are two disconnected concerns, separation of this them is properly defined and it specifies what is user interface and services. Client can’t have direct access to the database, assets or resources, which improves the portability of client code. Servers are not included in uder interface, which improves the simplicity and scalability of server-side code. Uniform interface links the client and server together. The two concerns can be developed indipendently as long as the interface is not altered. 

\item Cashable

Server responses (representations) are cashable, everything that comes back to server or from REST service could be cashable. Responses are able to to define themselfs as cashable implicitly (it’s not noted in general client), explicitly (server specifies) or negotiated (to figure out how long can be cashed), to avoid the inappropriate reuse of data contained in response in further requests. Cashing partially limits the clinet-server interacton but improves the scalability and performance.

\item Layered system

Linked to cashability and client-server. Client is not able to see if he is communicating diractly with the server, or wit som intermedia between them. Intermedia improves scalability, provide shared cashes and morover can enforce the security policies.

\item Code on demand (optional)

The logic can be transferred to the client-side, this way the server can temporarily extends or customize the functionality of the client. This can be performed for example by the components like service-side scripts.
This constraint is unique, it is the only one which can be violated and the services can be still reffered as RESTfull.

\end{enumerate}
\end{description}
%%\footnote{Technologie jsou popsány v sekci~\ref{sec:technologies}.} 


